import json
import os

#data 디렉토리 존재하지 않으면 생성
os.makedirs("data", exist_ok=True)

alpaca_data = [
{"instruction": "Analyze the pragma usage in the following Solidity contract snippet.", "input": "pragma solidity ^0.6.0;\n\ncontract test {\n   // Assume other required functionality is correctly implemented\n   // Assume this contract can work correctly without modifications across 0.6.x/0.7.x/0.8.x compiler versions\n}", "output": "Using 'pragma solidity ^0.6.0' allows testing with newer patch versions like 0.6.11 but also enables accidental deployment with buggy versions like 0.6.5. Moreover, using much older Solidity versions may expose the contract to known vulnerabilities fixed in later versions."},
{"instruction": "Identify vulnerabilities in the following Solidity snippet using selfdestruct.", "input": "pragma solidity 0.8.4;\n\ncontract test {\n   function kill() public {\n      selfdestruct(payable(0x0));\n   }\n}", "output": "The function 'kill()' is unprotected, allowing anyone to destroy the contract. Additionally, sending funds to the zero address effectively burns the contract balance."},
{"instruction": "Analyze the access control and fund transfer in this contract.", "input": "pragma solidity 0.8.4;\n\ncontract test {\n    modifier onlyAdmin() {\n        _;\n    }\n    function transferFunds(address payable recipient, uint amount) public {\n        recipient.transfer(amount);\n   }\n}", "output": "The 'transferFunds' function lacks the onlyAdmin modifier, resulting in unprotected access to withdraw funds from the contract."},
{"instruction": "Determine the behavior of getAddress() in the given contract.", "input": "pragma solidity 0.8.4;\ncontract test {\n    mapping (uint256 => address) addresses;\n    bool check;\n    modifier onlyIf() {\n        if (check) {\n            _;\n        }\n    }\n    function setAddress(uint id, address addr) public {\n        addresses[id] = addr;\n    }\n    function getAddress(uint id) public onlyIf returns (address) {\n        return addresses[id];\n    }\n}", "output": "If 'check' is true, getAddress() returns the expected address. If false, the function does nothing and implicitly returns the zero address."},
{"instruction": "Evaluate the delegatecall usage in the contract snippet.", "input": "pragma solidity 0.8.4;\n\ncontract test {\n    modifier onlyAdmin {\n        _;\n    }\n    function delegate (address addr) external {\n        addr.delegatecall(abi.encodeWithSignature(\"setDelay(uint256)\"));\n    }\n}", "output": "The delegate function lacks the onlyAdmin modifier and does not check if 'addr' is a valid contract. It also ignores the return value of delegatecall, which can be dangerous. This makes it vulnerable to unauthorized and uncontrolled delegatecall."},
{"instruction": "Identify the vulnerabilities in the following withdraw function.", "input": "pragma solidity 0.7.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract test {\n    mapping (address => uint256) balances;\n    function withdraw(uint256 amount) external nonReentrant {\n        msg.sender.call{value: amount}(\"\");\n        balances[msg.sender] -= amount;\n    }\n}", "output": "Missing check on user's balance before withdrawal can result in underflows. The call may also fail silently without reverting. Even with nonReentrant, best practice is to follow checks-effects-interactions."},
{"instruction": "Analyze the randomness logic in this contract.", "input": "pragma solidity 0.8.4;\n\ncontract test {\n    uint256 private constant secret = 123;\n    function diceRoll() external view returns (uint256) {\n        return (((block.timestamp * secret) % 6) + 1);\n    }\n}", "output": "block.timestamp is not a secure source of randomness, and the private constant 'secret' can be easily revealed by inspecting contract storage. This makes the diceRoll() output predictable."},
{"instruction": "Identify risks in the use of tx.origin for authentication.", "input": "pragma solidity 0.8.4;\n\ncontract test {\n    address admin;\n    modifier onlyAdmin {\n        require(tx.origin == admin);\n        _;\n    }\n    function emergencyWithdraw() external payable onlyAdmin {\n        msg.sender.transfer(address(this).balance);\n    }\n}", "output": "Using tx.origin instead of msg.sender for authentication exposes the contract to phishing and man-in-the-middle attacks. Also, there is no event logging the critical emergencyWithdraw."},
{"instruction": "Explain the flaw in the following contribute function.", "input": "pragma solidity 0.8.4;\n\ncontract test {\n    uint256 private constant MAX_FUND_RAISE = 100 ether;\n    mapping (address => uint256) contributions;\n    function contribute() external payable {\n        require(address(this).balance != MAX_FUND_RAISE);\n        contributions[msg.sender] += msg.value;\n    }\n}", "output": "Using strict inequality (!=) can allow the balance to exceed MAX_FUND_RAISE due to rounding or multiple contributions in the same block. Use '<=' or '<' with cumulative checks instead."},
{"instruction": "What will the require statement in callMe() check for?", "input": "pragma solidity 0.8.4;\n\ncontract test {\n    function callMe (address target) external {\n        (bool success, ) = target.call(\"\");\n        require(success);\n    }\n}", "output": "Calling a non-existent contract address will return success = true, unless a revert happens. So this check will pass even for externally owned accounts, which may not be intended."},
{"instruction": "Identify the security issues in the following admin change function.", "input": "pragma solidity 0.8.4;\n\ncontract test {\n    address admin;\n    function setAdmin (address _newAdmin) external {\n        admin = _newAdmin;\n    }\n}", "output": "The function lacks access control, allowing anyone to change the admin. It also lacks zero-address validation, emits no event, and allows critical change in a single step."},
{"instruction": "Analyze the liquidity management logic in this contract.", "input": "pragma solidity 0.8.4;\n\ncontract test {\n    address admin;\n    address payable pool;\n    constructor(address _admin) {\n        admin = _admin;\n    }\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n    function setPoolAddress(address payable _pool) external onlyAdmin {\n        pool = _pool;\n    }\n    function addLiquidity() payable external {\n        pool.transfer(msg.value);\n    }\n}", "output": "This contract assumes that setPoolAddress is always called before addLiquidity, but there's no safeguard to enforce it. Also, _pool should be checked for zero address and the contract is vulnerable to front-running by admin."},
{"instruction": "Evaluate proxy initialization and reward setting logic.", "input": "pragma solidity 0.8.4;\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/proxy/utils/Initializable.sol\";\n\ncontract test is Initializable {\n    address admin;\n    uint256 rewards = 10;\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n    function initialize (address _admin) external {\n        require(_admin != address(0));\n        admin = _admin;\n    }\n    function setRewards(uint256 _rewards) external onlyAdmin {\n        rewards = _rewards;\n    }\n}", "output": "The initialize() function is not protected against multiple calls, allowing the admin to be overwritten. Additionally, rewards will remain zero in the proxy until set manually, which can lead to unintended behavior."},
{"instruction": "Identify problems in reward distribution via ERC20 transfer.", "input": "pragma solidity 0.8.4;\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\n\ncontract test {\n    address admin;\n    address token;\n    constructor(address _admin, address _token) {\n        require(_admin != address(0));\n        require(_token != address(0));\n        admin = _admin;\n        token = _token;\n    }\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n    function payRewards(address[] calldata recipients, uint256[] calldata amounts) external onlyAdmin {\n        for (uint i; i < recipients.length; i++) {\n            IERC20(token).transfer(recipients[i], amounts[i]);\n        }\n    }\n}", "output": "The loop can cause out-of-gas issues for large input arrays. The function does not validate the length of input arrays and ignores the return value of the transfer function, which can lead to silent failures."},
{"instruction": "Identify vulnerabilities in this withdrawBalance function.", "input": "pragma solidity 0.8.4;\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol\";\n\ncontract test {\n    mapping (address => uint256) balances;\n    function withdrawBalance() external {\n        msg.sender.call{value: balances[msg.sender]}(\"\");\n        balances[msg.sender] = 0;\n    }\n}", "output": "The withdrawBalance function is vulnerable to reentrancy because it transfers funds before resetting the user\u2019s balance. Always follow the checks-effects-interactions pattern."},
{"instruction": "Analyze the risks in the following ECDSA verification function.", "input": "pragma solidity 0.8.4;\n\ncontract test {\nfunction verify(address signer, bytes32 memory hash, bytes32 sigR, bytes32 sigS, uint8 sigV) internal view returns (bool) {\n   return signer == ecrecover(hash, sigV, sigR, sigS);\n}\n}", "output": "The function does not prevent signature malleability, omits use of chainID or nonce in hash, and does not check that the recovered address is non-zero. These issues can lead to replay and forgery attacks."} ]

with open("race0_q1_q16_full_alpaca.jsonl", "w", encoding="utf-8") as f:
    for entry in alpaca_data:
        f.write(json.dumps(entry, ensure_ascii=False) + "\n")


with open("race0_q1_q16_full_alpaca.jsonl", "r") as f:
    alpaca_data = [json.loads(line) for line in f]